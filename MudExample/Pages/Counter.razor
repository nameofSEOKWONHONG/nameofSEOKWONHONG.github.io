@page "/counter"

@using eXtensionSharp
@using KristofferStrube.Blazor.WebAudio
@using Color = MudBlazor.Color
@using Size = MudBlazor.Size
@inject HttpClient HttpClient
@inject IJSRuntime JSRuntime
@inherits PageComponentBase

<MudContainer MaxWidth="MaxWidth.ExtraLarge">
    <MudBreadcrumbs Items="@Breadcrumbs"></MudBreadcrumbs>
    
    <MudProgressLinear Color="Color.Info" Size="Size.Large" Value="@_currentCount" Class="my-7">
        <MudText Typo="Typo.subtitle1" Color="Color.Dark">
            <b>@_currentCount%</b>
        </MudText>
    </MudProgressLinear>

    <div>
        <MudChart ChartType="ChartType.Line" ChartSeries="@Series" @bind-SelectedIndex="Index" XAxisLabels="@XAxisLabels" Width="100%" Height="350px" ChartOptions="@Options" @ref="Chart"/>
        <MudGrid>
            <MudItem xs="6">
                <MudText Typo="Typo.body1" Class="py-3">Selected: @(Index < 0 ? "None" : Series[Index].Name)</MudText>
            </MudItem>
            <MudItem xs="6">
                <MudSlider @bind-Value="Options.LineStrokeWidth" Min="1" Max="10" Color="Color.Info">Line Width: @Options.LineStrokeWidth.ToString()</MudSlider>
            </MudItem>
        </MudGrid>
    </div>    
    
    <MudText Typo="Typo.h6">MudBlazor is @_text</MudText>
    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ButtonOnClick">@_buttonText</MudButton>
    
    <br/>
    <br/>

    <MudPaper Class="d-flex flex-column flex-grow-1 gap-4" Elevation="0">
        <MudPaper Class="d-flex justify-center flex-grow-1 gap-4" Elevation="0">
            @if (_isShuffle)
            {
                <MudIconButton Variant="Variant.Text" Icon="@Icons.Material.Filled.ShuffleOn" OnClick="RandomizeTracks"/>
            }
            else
            {
                <MudIconButton Variant="Variant.Text" Icon="@Icons.Material.Filled.Shuffle" OnClick="RandomizeTracks"/>
            }
            <MudIconButton Variant="Variant.Text" Icon="@Icons.Material.Filled.ArrowLeft" OnClick="PreviousTrack"/>
            @if (playing)
            {
                <MudIconButton Variant="Variant.Text" Icon="@Icons.Material.Filled.PauseCircle" OnClick="Pause"/>
            }
            else
            {
                <MudIconButton Variant="Variant.Text" Icon="@Icons.Material.Filled.PlayArrow" OnClick="Play"/>
            }
            <MudIconButton Variant="Variant.Text" Icon="@Icons.Material.Filled.ArrowRight" OnClick="NextTrack"/>

            @if (_repeatMode == 0)
            {
                <MudIconButton Variant="Variant.Text" Icon="@Icons.Material.Filled.Repeat" OnClick="@(() => _repeatMode = 1)"/>
            }
            else if (_repeatMode == 1)
            {
                <MudIconButton Variant="Variant.Text" Icon="@Icons.Material.Filled.RepeatOn" OnClick="@(() => _repeatMode = 2)"/>
            }
            else
            {
                <MudIconButton Variant="Variant.Text" Icon="@Icons.Material.Filled.RepeatOne" OnClick="@(() => _repeatMode = 0)"/>
            }
        </MudPaper>
        <MudPaper Class="d-flex justify-center flex-grow-1 gap-4" Elevation="0">
            <MudText Typo="Typo.inherit" Color="Color.Primary">
                @TimeSpan.FromSeconds(playTime).ToString(@"mm\:ss")
            </MudText>            
            <MudProgressLinear Color="Color.Info" Size="Size.Large" Value="@playTime" Max="@trackDuration" Class="my-1">
            </MudProgressLinear>
            <MudText Typo="Typo.inherit" Color="Color.Secondary">
                @TimeSpan.FromSeconds(trackDuration).ToString(@"mm\:ss")
            </MudText>            
        </MudPaper>
        <audio hidden><source src="mp3/Adam_MacDougall.mp3"/></audio>
    </MudPaper>

</MudContainer>


@code {
    private int _repeatMode;
    private bool _isShuffle;
    private int _currentCount = 0;
    private string _text { get; set; } = "????";
    private string _buttonText { get; set; } = "Click Me";
    
    private AudioContext context = default!;
    private AudioDestinationNode destination = default!;
    private AudioBufferSourceNode currentAudioBufferNode = default!;
    private AudioBuffer currentAudioBuffer = default!;
    
    private int Index = -1; //default value cannot be 0 -> first selectedindex is 0.
    public ChartOptions Options = new ChartOptions();
    
    public List<ChartSeries> Series = new List<ChartSeries>()
    {
        new ChartSeries() { Name = "Fossil", Data = new double[]{}},
        new ChartSeries() { Name = "Renewable", Data = new double[]{}},
    };
    public string[] XAxisLabels = { };

    List<double> data1 = new();
    List<double> data2 = new();
    
    MudChart Chart { get; set; }
    
    public async Task EnsureInitialized()
    {
        if (context is { }) return;

        context = await AudioContext.CreateAsync(JSRuntime);
        destination = await context.GetDestinationAsync();
    }
    
    private bool playing;
    private bool currentTrackLoaded = false;
    private int currentTrack = 0;
    private double playTime;
    private double startTime;
    private double? pauseTime;
    private double offset;
    private double trackDuration;
    private int interactions;
    private List<string> tracks = new() {
        "mp3/Adam_MacDougall.mp3"
    };
    private byte[]?[] loadedTracks = new byte[]?[4];

    public async Task EnsureCurrentTrackLoaded()
    {
        if (currentTrackLoaded) return;

        // Dispose old audio buffer
        if (currentAudioBuffer is not null)
        {
            await currentAudioBuffer.DisposeAsync();
        }

        if (loadedTracks[currentTrack].xIsEmpty())
        {
            loadedTracks[currentTrack] = await HttpClient.GetByteArrayAsync(tracks[currentTrack]);
        }
        AudioBuffer nextAudioBuffer = await context.DecodeAudioDataAsync(loadedTracks[currentTrack]);

        currentAudioBuffer = nextAudioBuffer;
        trackDuration = await currentAudioBuffer.GetDurationAsync();

        currentTrackLoaded = true;
    }
    
    public async Task Play()
    {
        await EnsureInitialized();
        if (playing) return;
        interactions++;
        await EnsureCurrentTrackLoaded();

        currentAudioBufferNode = await context.CreateBufferSourceAsync();
        await currentAudioBufferNode.SetBufferAsync(currentAudioBuffer);
        await currentAudioBufferNode.ConnectAsync(destination);
        if (pauseTime is null)
        {
            await currentAudioBufferNode.StartAsync();
        }
        else
        {
            await currentAudioBufferNode.StartAsync(when: 0, offset: offset);
        }
        startTime = await context.GetCurrentTimeAsync();

        playing = true;
        var currentInteractions = interactions;
        while (currentInteractions == interactions)
        {
            playTime = await context.GetCurrentTimeAsync() - startTime + offset;
            StateHasChanged();
            if (playTime >= trackDuration)
            {
                await Pause();
            }
            await Task.Delay(100);
        }
    }
    
    public async Task Pause()
    {
        if (!playing) return;
        interactions++;

        await currentAudioBufferNode.DisconnectAsync();
        await currentAudioBufferNode.StopAsync();
        await currentAudioBufferNode.DisposeAsync();

        var currentTime = await context.GetCurrentTimeAsync();
        pauseTime = await context.GetCurrentTimeAsync();
        if (offset + currentTime - startTime > trackDuration)
        {
            offset = 0;
        }
        else
        {
            offset += currentTime - startTime;
        }

        playing = false;
    }
    
    public Task PreviousTrack() => SwitchTrack(() => currentTrack = (currentTrack - 1 + tracks.Count) % tracks.Count);
    public Task NextTrack() => SwitchTrack(() => currentTrack = (currentTrack + 1) % tracks.Count);
    
    private async Task SwitchTrack(Action changeTrack)
    {
        await EnsureInitialized();

        var wasPlaying = playing;
        if (wasPlaying)
        {
            await Pause();
        }
        changeTrack();
        currentTrackLoaded = false;
        await EnsureCurrentTrackLoaded();
        offset = 0;
        playTime = 0;
        if (wasPlaying)
        {
            await Play();
        }
    }
    
    public async Task RandomizeTracks()
    {
        _isShuffle = !_isShuffle;
        
        var wasPlaying = playing;
        if (wasPlaying)
        {
            await Pause();
        }
        tracks = tracks.OrderBy(x => Random.Shared.Next()).ToList();
        loadedTracks = new byte[]?[4];
        currentTrackLoaded = false;
        currentTrack = 0;
        offset = 0;
        playTime = 0;
        if (wasPlaying)
        {
            await Play();
        }
    }
    
    void ButtonOnClick()
    {
        _currentCount += 10;
        if (_currentCount > 100)
        {
            _currentCount = 0;
            data1.Clear();
            data2.Clear();
        }

        Random random = new Random();
        data1.AddRange(Enumerable.Range(1, 100)
            .OrderBy(x => random.Next())
            .Select(m => (double)m)
            .Take(10)
            .ToList());
        data2.AddRange(Enumerable.Range(1, 100)
            .OrderBy(x => random.Next())
            .Select(m => (double)m)
            .Take(10)
            .ToList());
        Series[0].Data = data1.ToArray();
        Series[1].Data = data2.ToArray(); 
        
        _text = $"Awesome x {_currentCount}";
        _buttonText = "Click Me Again";
    }

    public override async ValueTask DisposeAsync()
    {
        await Pause();
    }

}